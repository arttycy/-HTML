<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>塔罗占卜 Demo</title>
<style>
    body {
    font-family: sans-serif;
    background-color: #9a9ad9;
    display: flex;
    justify-content: center;
    align-items: flex-start; /* 将垂直居中对齐，改为“顶部对齐” */
    min-height: 100vh;     /* 将 height 改为 min-height，允许内容撑开页面 */
    margin: 0;
    padding: 40px 0;         /* 增加一些上下边距，让长页面顶部和底部不贴边 */
    box-sizing: border-box;  /* 确保 padding 不会影响总高度计算 */
}
body {
    /* ... 其他样式 ... */
    background-image: url('images/background_pic.jpg');
    background-size: cover;       /* 确保背景图片覆盖整个视口 */
    background-position: center;  /* 图片居中显示 */
    background-repeat: no-repeat; /* 不重复平铺 */
    background-attachment: fixed; /* 背景固定，不随页面滚动 */
    
    /* 为了确保图片加载前有背景色，或者图片加载失败时有兜底 */
    background-color: #333; /* 推荐设置一个与图片色调相近的纯色作为兜底 */
}
body {
    /* ... 上面设置的背景图片样式 ... */
    position: relative; /* 允许在其上叠加伪元素 */
    z-index: 1;         /* 确保其他内容在背景之上 */
}
body::before { /* 创建一个伪元素作为半透明蒙版 */
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(222, 223, 219, 0.4); /* 黑色半透明蒙版，0.4是透明度，可调 */
    z-index: -1; /* 确保蒙版在内容之下，但在背景图片之上 */
}
    .page-container { background-color: #fff; padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); width: 90%; max-width: 400px; text-align: center; }
    .hidden { display: none; }
    input, select, textarea, button { width: 100%; padding: 10px; margin: 6px 0; box-sizing: border-box; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; transition: border-color 0.3s; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;}
    #birthday { font-size: 12px; }
    input:focus, select:focus, textarea:focus { border-color: #007bff; outline: none; box-shadow: 0 0 0 2px rgba(0,123,255,0.25); }
    input:invalid { border-color: #dc3545; }
    label { display: block; text-align: left; font-weight: bold; margin-top: 15px; }
    button { background-color: #007bff; color: white; cursor: pointer; border: none; }
    button:hover { background-color: #0056b3; }
    #logout-btn { background-color: #6c757d; margin-top: 15px; }
    .result-display { min-height: 200px; max-height: 400px; text-align: left; white-space: pre-wrap; background-color: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; overflow-y: auto; line-height: 1.6; }
    .hint { display: block; text-align: left; font-size: 12px; color: #6c757d; margin-top: 2px; margin-bottom: 10px; }
    /* 选中包含月份和年份的整个区域 */
.flatpickr-months {
    font-size: 10px;   /* <--- 整体调整字号 */
    font-weight: normal;  /* 调整字重，比如 normal (普通) 或 600 (稍粗) */
    color: #333;       /* 调整文字颜色 */
}
    #city::placeholder,
    #question::placeholder {
        font-family: sans-serif;     /* 1. 统一字体 */
        font-size: 14px;             /* 2. 统一字号 (和输入框字号一致) */
        color: #aaa;                  /* 3. 统一颜色 (比输入的文字颜色浅一些) */
    }
        /* --- 新增的三模块布局样式 --- */
    .module {
        margin-bottom: 25px;
        border-top: 1px solid #eee;
        padding-top: 20px;
        text-align: left;
    }
    /* .module h2 {
        text-align: center;
        font-size: 1.4em;
        color: #333;
        margin-top: 0;
        margin-bottom: 20px;
    } */
    
    .card-container {
        display: flex;
        justify-content: space-around;
        gap: 10px;
        flex-wrap: wrap; /* 移动端换行 */
    }
    .tarot-card-item {
        text-align: center;
        flex-basis: 100px; /* 每个卡牌的基础宽度 */
    }
    .tarot-card-image {
        width: 90px;
        height: auto;
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        transition: transform 0.3s;
    }
    .tarot-card-image:hover {
        transform: scale(1.05) translateY(-5px);
    }
    .tarot-card-item p {
        font-size: 13px;
        margin-top: 8px;
        font-weight: 500;
        color: #555;
    }
    .card-interpretation {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #f0f0f0;
    }
    .card-interpretation:last-child {
        border-bottom: none;
    }
    .summary-section h4 {
        color: #1a2a4e;
    }
    /* --- 解决结果内容显示不全的问题 --- */
    #result-page {
    max-height: 85vh;  /* 设置结果页卡片的最大高度为视窗高度的85%  */
    overflow-y: auto;   /* 当内容超出时，卡片内部出现垂直滚动条 */
    padding-right: 15px; /* (可选) 增加右内边距，防止滚动条压住文字*/
    font-size: 15px; /* 设置结果页面的基础字体大小 */
    line-height: 1.6; /* 增加行高，提高可读性 */
}

    /* --- 卡牌文字和标签样式优化 --- */

    /* 调整卡牌名字的样式 */
    .tarot-card-item .card-name-display {
        font-size: 15px; /* 牌名稍大一点 */
        font-weight: 600; /* 牌名加粗 */
        color: #333; /* 更深的颜色 */
        margin-top: 10px; /* 牌名和图片之间多一些空间 */
        margin-bottom: 5px; /* 牌名和标签之间留空间 */
        line-height: 1.3;
    }

    /* 卡牌类型标签的基础样式 */
    .card-type-tag {
        display: inline-block; /* 让标签像一个块级元素一样，可以设置padding */
        padding: 4px 10px; /* 增加内边距 */
        border-radius: 6px; /* 增加圆角 */
        font-size: 13px; /* 增加标签字体大小 */
        font-weight: 500; /* 标签字体粗细 */
        line-height: 1; /* 行高，确保文字居中 */
        color: #fff; /* 文字颜色为白色 */
        margin-top: 5px; /* 与牌名之间的间距 */
        box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* 增强阴影效果，增加立体感 */
    }

    /* 正位标签的特定颜色 */
    .card-type-positive {
        background-color: #E8F5E9; /* 这是一个非常柔和的淡绿色 */
        color: #388E3C;           /* 这是与之搭配的、更深一点的绿色文字，确保清晰可读 */
    }

    /* 逆位标签的特定颜色 */
    .card-type-negative {
        /*background-color: #F44336; 红色 */
        background-color: #FFEBEE; /* 这是一个非常柔和的淡红色/粉色 */
        color: #D32F2F;           /* 这是与之搭配的、更深一点的红色文字，确保清晰可读 */
    }

    /* 调整卡牌整体的间距，防止标签被挤压 */
    .tarot-card-item {
        text-align: center;
        flex-basis: 100px; /* 每个卡牌的基础宽度 */
        min-width: 90px;   /* 确保在小屏幕下也有最小宽度 */
        padding: 5px;      /* 增加一点内边距，避免内容过于贴边 */
    }
    /* --- 全新黄色/土黄色主题 --- */

    /* 1. 主要按钮和交互元素的颜色 */
    button,
    #login-btn,
    #divine-btn {
        background-color: #ff9500; /* 定义主题色为：黄色 */
        transition: background-color 0.3s;
        font-weight: 600; /* 让按钮文字稍粗一点，更有质感 */
    }
    button:hover,
    #login-btn:hover,
    #divine-btn:hover {
        background-color: #A0740A; /* 鼠标悬停时颜色加深 */
    }
    /* 其他特殊按钮可以保持灰色 */
    #logout-btn { background-color: #b8bdc0; }
    #clear-birthday {
        background-color: #ff9500; /* 和“退出登录”按钮颜色一致，作为默认色 */
        color: white;
        cursor: pointer;
        border: none;
        transition: background-color 0.2s, transform 0.1s; /* 增加过渡效果，让变化更平滑 */
    }
    #clear-birthday:active {
    background-color: #5a6268;   /* 这是按下时才会变成的深灰色 */
}

    /* 2. 输入框聚焦时的辉光效果 */
    input:focus, select:focus, textarea:focus {
        border-color: #B8860B; /* 边框也使用主题色 */
        box-shadow: 0 0 0 3px rgba(184, 134, 11, 0.25); /* 土黄色的辉光 */
    }

    /* 3. (可选) 优化卡片和标题颜色以匹配主题 */
    .page-container {
        background-color: #FAF9F6; /* 使用一个更柔和的米白色代替纯白，更有羊皮纸的感觉 */
        border: 1px solid #EAE0B2; /* 给卡片一个淡淡的金色边框 */
    }

    h1, h2 {
        color: #5C523A; /* 深橄榄/棕色标题，比纯黑更柔和 */
    }

    /* --- 建议模块的卡片式布局样式 --- */
    .suggestions-container {
        display: flex;
        flex-direction: column; /* 垂直排列卡片 */
        gap: 15px; /* 卡片之间的间距 */
    }

    .suggestion-card {
        display: flex;
        align-items: flex-start; /* 图标和文字顶部对齐 */
        background-color: #FFFFFF;
        padding: 15px 20px;
        /* 【圆角】 你可以调整这个值，比如 12px 会更圆滑 */
        border-radius: 12px; 
    
    /* 【框线】 添加一个完整、柔和的灰色边框 */
        border: 1px solid #EAE0B2; /* 使用一个和主题色协调的淡金色边框 */
        transition: box-shadow 0.3s, border-color 0.3s;

    }
    .suggestion-card:hover {
        box-shadow: 0 4px 12px rgb(251, 232, 198);
    }

    .suggestion-icon {
        font-size: 1.5em; /* 图标大小 */
        margin-right: 15px;
        line-height: 1.4; /* 调整行高让图标和文字更对齐 */
    }

    .suggestion-text {
        font-size: 14px;
        line-height: 1.7;
        color: #333;
    }
    /* --- 为 H2 标题添加左右对称的装饰符号 --- */

/* 第一步：修改 h2 自身的样式 */
    h2 {
        /* 将标题自身变为 Flex 容器 */
        display: flex;
        justify-content: center; /* 水平居中所有子项目 */
        align-items: center;     /* 垂直居中所有子项目 */
        
        /* 原有的样式可以保留或微调 */
        width: 100%;             /* 确保 h2 撑满容器宽度以便正确居中 */
        font-size: 1.5em;
        font-weight: 600;
        color: #483D8B;
        margin-top: 0;
        margin-bottom: 25px;
        border-bottom: none; /* 移除之前可能添加的下划线 */
        padding-bottom: 0;   /* 移除之前可能添加的内边距 */
    }

    /* 第二步：同时定义左右两个符号的样式 */
    h2::before,
    h2::after {
        /* 定义符号的内容 */
        content: '✦';
        font-size: 18px;
        color: #D4AF37;
        
        /* 使用 margin 在符号和文字之间制造间距 */
        margin: 0 15px; /* 上下间距为0，左右间距为15px */
        
        /* 由于使用了Flexbox，不再需要 position: absolute; 等定位代码 */
    }

</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    </head>
<body>

    <div id="login-page" class="page-container">
        <h1>欢迎来到塔罗小屋</h1>
        <p>请输入你的昵称开始</p>
        <input type="text" id="name-input" placeholder="输入你的昵称">
        <button id="login-btn">进入</button>
    </div>

    <div id="input-page" class="page-container hidden">
        <h2 id="welcome-message">你好！</h2>
        <p>请填写你的信息，让占卜更准确</p>
        <form id="tarot-form">
            <label for="birthday">你的生日:</label>
            <div style="display: flex; gap: 8px;">
                <input type="text" id="birthday" placeholder="请选择你的生日..." required style="flex: 1;">
                <button type="button" id="clear-birthday" style="width: auto; padding: 12px;">清除</button>
            </div>
            <span class="hint">请选择您的出生日期(格式: YYYY-MM-DD)</span>

            <label for="gender">你的性别:</label>
            <select id="gender" required>
                <option value="">请选择...</option>
                <option value="男">男</option>
                <option value="女">女</option>
                <option value="其他">其他</option>
            </select>

            <label for="city">出生城市:</label>
            <input type="text" id="city" placeholder="请输入您的出生城市，例如：北京、上海" required>
            <span class="hint">用于占卜时考虑时区和经纬度</span>

            <label for="question">你想要占卜的问题:</label>
            <textarea id="question" placeholder="例如：帮我占卜一下事业运势吧。" rows="4" required minlength="5" maxlength="200"></textarea>
            <span class="hint">请输入您想占卜的问题 (<span id="char-count">0</span>/200 字符)</span>

            <button type="submit" id="divine-btn">开始占卜</button>
        </form>
        <button id="logout-btn">退出登录</button>
    </div>

    <div id="result-page" class="page-container hidden">
    <h1>占卜结果</h1>
    <div id="loading-message" style="text-align: center; padding: 20px; font-size: 16px;">
        <p>正在为你连接星辰，解读牌阵，请稍候...</p>
    </div>
    <div id="result-modules" style="display: none;">
        <div id="module-cards" class="module">
            <h2>你抽到的牌</h2>
            <div id="card-display-area" class="card-container">
                </div>
        </div>

        <div id="module-interpretations" class="module">
            <h2>牌面解读</h2>
            <div id="interpretation-area">
                </div>
        </div>

        <div id="module-summary" class="module">
            <h2>综合分析与建议</h2>
            <div id="summary-area">
                </div>
        </div>
    </div>

    <button id="back-btn">返回再问一次</button>
</div>

<script src="config.js"></script>
<script>
    // --- 元素获取 ---
    const loginPage = document.getElementById('login-page');
    const inputPage = document.getElementById('input-page');
    const resultPage = document.getElementById('result-page');
    // 登录页元素
    const nameInput = document.getElementById('name-input');
    const loginBtn = document.getElementById('login-btn');
    // 输入页元素
    const welcomeMessage = document.getElementById('welcome-message');
    const tarotForm = document.getElementById('tarot-form');
    const birthdayInput = document.getElementById('birthday');
    const genderSelect = document.getElementById('gender');
    const cityInput = document.getElementById('city');
    const questionTextarea = document.getElementById('question');
    const logoutBtn = document.getElementById('logout-btn');
    // 结果页元素
    /*const resultDisplay = document.getElementById('result-display'); */
    const backBtn = document.getElementById('back-btn');

    // --- 页面切换逻辑 ---
    function showPage(page) {
        loginPage.classList.add('hidden');
        inputPage.classList.add('hidden');
        resultPage.classList.add('hidden');
        page.classList.remove('hidden');
    }

    // --- 核心功能函数 ---
    // 检查登录状态
    function checkLogin() {
        const name = localStorage.getItem('tarotUserName');
        if (name) {
            welcomeMessage.innerText = `你好，${name}！`;
            showPage(inputPage);
        } else {
            showPage(loginPage);
        }
    }
    // 初始化生日选择器
    flatpickr("#birthday", {
        dateFormat: "Y-m-d",
        maxDate: "today",
        defaultDate: "1990-01-01",
        allowInput: false,
        locale: {
            weekdays: {
                shorthand: ['周日', '周一', '周二', '周三', '周四', '周五', '周六'],
                longhand: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']
            },
            months: {
                shorthand: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],
                longhand: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月']
            },
            firstDayOfWeek: 1,
            rangeSeparator: ' 至 ',
            weekAbbreviation: '周',
            scrollTitle: '滚动切换',
            toggleTitle: '点击切换 12/24 小时时制'
        }
    });
    
    // 登录
    loginBtn.addEventListener('click', () => {
        const name = nameInput.value.trim();
        if (name) {
            localStorage.setItem('tarotUserName', name);
            checkLogin();
        } else {
            alert('昵称不能为空！');
        }
    });

    // 退出登录
    logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('tarotUserName');
        checkLogin();
    });
    
    // 设置生日输入的最大日期为今天
    const today = new Date().toISOString().split('T')[0];
    birthdayInput.max = today;
    
    // 清除生日按钮事件
    document.getElementById('clear-birthday').addEventListener('click', () => {
        birthdayInput._flatpickr.clear();
    });
    
    // 提交占卜信息
    tarotForm.addEventListener('submit', (event) => {
        event.preventDefault(); // 阻止表单默认提交行为
        
        // 验证生日日期不能超过今天
        if (birthdayInput.value > today) {
            alert('生日不能超过今天！');
            return;
        }
        
        const userData = {
            name: localStorage.getItem('tarotUserName'),
            birthday: birthdayInput.value,
            gender: genderSelect.value,
            city: cityInput.value,
            question: questionTextarea.value
        };
        performDivination(userData);
    });

    // 返回按钮
    backBtn.addEventListener('click', () => {
        showPage(inputPage);
    });
    
    // 问题输入框字符计数
    questionTextarea.addEventListener('input', () => {
        const charCount = questionTextarea.value.length;
        document.getElementById('char-count').textContent = charCount;
        
        // 当字符数接近限制时改变颜色
        const countElement = document.getElementById('char-count');
        if (charCount > 180) {
            countElement.style.color = '#dc3545';
        } else if (charCount > 150) {
            countElement.style.color = '#ffc107';
        } else {
            countElement.style.color = '#6c757d';
        }
    });


// 调用 Agent API 进行占卜
// ▼▼▼ 替换旧的 performDivination 函数 ▼▼▼
async function performDivination(userData) {
    showPage(resultPage);
    // 显示加载消息，隐藏结果模块
    document.getElementById('loading-message').style.display = 'block';
    document.getElementById('result-modules').style.display = 'none';

    const headers = {
        'Authorization': YOUR_ACCESS_TOKEN,
        'Content-Type': 'application/json'
    };
    const body = {
        workflow_id: YOUR_WORKFLOW_ID,
        parameters: {
            birthday: userData.birthday,
            gender: userData.gender,
            city: userData.city,
            question: userData.question
        },
        user_id: userData.name || 'default_user'
    };
    // ... (你已有的构建 body 的代码保持不变)

    try {
        const response = await fetch('https://api.coze.cn/v1/workflow/run', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body)
        });

        if (!response.ok) throw new Error(`网络请求失败: ${response.status}`);

        const result = await response.json();
        console.log('从 Coze API 收到的完整响应:', result);

        if (result.code !== 0) throw new Error(`API 错误: ${result.msg}`);

        // --- 全新渲染逻辑 ---
        
        // 1. 清理并解析最终的 JSON 数据
        // Coze 返回的 output 是一个包含 ```json ... ``` 的字符串
        let jsonString = JSON.parse(result.data).output;
        // 移除 Markdown 的代码块标记
        jsonString = jsonString.replace(/^```json\n/, '').replace(/\n```$/, '');
        const finalData = JSON.parse(jsonString);
        console.log('最终用于渲染页面的结构化数据:', finalData);

        // 2. 渲染模块一：抽取的卡牌
        /* const cardArea = document.getElementById('card-display-area');
        cardArea.innerHTML = finalData.drawn_cards.map(card => `
            <div class="tarot-card-item">
                <img src="${card.image_url}" alt="${card.name} - ${card.type}" class="tarot-card-image">
                <p>${card.type}的<br>${card.name}</p>
            </div>
        `).join('');
        */
        const cardArea = document.getElementById('card-display-area');
        cardArea.innerHTML = finalData.drawn_cards.map(card => {
            // 根据牌的类型决定标签的颜色
            const typeClass = card.type === '正位' ? 'card-type-positive' : 'card-type-negative';
            // 完整的牌名，不包含正逆位（因为正逆位会单独做成标签）
            const cardNameOnly = card.name; 

            return `
                <div class="tarot-card-item">
                    <img src="${card.image_url}" alt="${card.type}的${cardNameOnly}" class="tarot-card-image">
                    <p class="card-name-display">${cardNameOnly}</p>
                    <span class="card-type-tag ${typeClass}">${card.type}</span>
                </div>
            `;
        }).join('');

        // 3. 渲染模块二：卡牌解读
        const interpretationArea = document.getElementById('interpretation-area');
        interpretationArea.innerHTML = finalData.interpretations.map(interp => `
            <div class="card-interpretation">
                <h4>🃏 ${interp.type}的${interp.card_name}</h4>
                <p><strong>💡 牌面含义:</strong> ${interp.meaning}</p>
                <p><strong>📋 结合星盘分析:</strong> ${interp.analysis}</p>
            </div>
        `).join('');

        // 4. 渲染模块三：综合分析与建议
        const summaryArea = document.getElementById('summary-area');
        if (finalData.summary) {
            // 首先渲染分析部分
            let summaryHtml = `
                <div class="summary-section">
                    <h4>星盘综合提示</h4>
                    <p>${finalData.summary.star_chart_analysis}</p>
                    <h4>整体分析</h4>
                    <p>${finalData.summary.comprehensive_analysis}</p>
                    <h4>给你的建议</h4>
                </div>
            `;

        // 然后，遍历 suggestions 数组来创建卡片
        const suggestionsHtml = finalData.summary.suggestions.map(sugg => `
            <div class="suggestion-card">
                <div class="suggestion-icon">${sugg.icon}</div>
                <div class="suggestion-text">${sugg.advice}</div>
            </div>
        `).join('');

        // 将分析和建议卡片组合起来
        summaryArea.innerHTML = summaryHtml + `<div class="suggestions-container">${suggestionsHtml}</div>`;
}
        // 隐藏加载消息，显示结果模块
        document.getElementById('loading-message').style.display = 'none';
        document.getElementById('result-modules').style.display = 'block';

        console.log('工作流执行成功!', result);
        console.log('调试链接:', result.debug_url);

    } catch (error) {
        console.error('占卜时出错:', error);
        // 隐藏加载消息，显示结果模块
        document.getElementById('loading-message').style.display = 'none';
        document.getElementById('result-modules').style.display = 'block';
        // 如果出错，只在解读区显示错误信息
        document.getElementById('interpretation-area').innerHTML = `<p>出现了一个错误：<br>${error.message}<br>请检查令牌和网络后重试。</p>`;
    }
}
/*
async function performDivination(userData) {
    showPage(resultPage);
    resultDisplay.innerText = '正在为你连接星辰，解读牌阵，请稍候...';
    // ---- 根据 Coze API 文档构建请求 ----
    // 1. 构建请求头 (Headers)
    const headers = {
        'Authorization': YOUR_ACCESS_TOKEN,
        'Content-Type': 'application/json'
    };

    // 2. 构建请求体 (Body)
    const body = {
        workflow_id: YOUR_WORKFLOW_ID,
        parameters: {
            birthday: userData.birthday,
            gender: userData.gender,
            city: userData.city,
            question: userData.question
        },
        // Coze API 要求有一个 user_id 来区分用户
        user_id: userData.name || 'default_user' 
    };

    // 3. 使用 fetch 发送网络请求
    try {
        const response = await fetch('https://api.coze.cn/v1/workflow/run', {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(body)
        });

        if (!response.ok) {
            throw new Error(`网络请求失败: ${response.status} ${response.statusText}`);
        }

        const result = await response.json();
        console.log('从 Coze API 收到的完整响应:', result);
        if (result.code !== 0) {
            throw new Error(`API 错误: ${result.msg}`);
        }
        const workflowResult = result.data; // 从 result.data 获取数据
        let finalAnswer = '';
        try {
            const parsedData = JSON.parse(workflowResult);
            finalAnswer = parsedData.output; // 从解包后的数据里获取 output
        } catch (e) {
            finalAnswer = workflowResult;
        }

        if (!finalAnswer) {
            finalAnswer = '工作流执行成功，但未能返回有效结果。';
        }
        resultDisplay.innerHTML = marked.parse(finalAnswer);
        console.log('工作流执行成功!', result);
        console.log('调试链接:', result.debug_url);

    } catch (error) {
        console.error('占卜时出错:', error);
        resultDisplay.innerText = `出现了一个错误：\n${error.message}\n请检查令牌和网络后重试。`;
    }
}
*/

    // --- 初始化 ---
    // 页面加载时，首先检查登录状态
    checkLogin();

</script>
    </body>
</html>
